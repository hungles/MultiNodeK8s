#!/bin/bash

requirements=("terraform" "ansible" "aws")
missing=()
main_file=terraform/main.tf
output_file=terraform/outputs.tf
os_file=terraform/variables.tf
variables_file=terraform/variables.tf
options=("Ubuntu" "Debian" "Amazon Linux")
selected=0
KUBE_DIR="$HOME/.kube"
CONFIG_FILE="$KUBE_DIR/config"

# Sample map of AMIs by OS (you can replace this with actual values)
declare -A ami_map=( ["Ubuntu"]="ami-0f9de6e2d2f067fca" ["Debian"]="ami-0779caf41f9ba54f0" ["CentOS"]="ami-centos" )

# Kubernetes version options
k8s_versions=("1.31" "1.32" "1.33")
k8s_version_codes=("k31" "k32" "k33")

# Declare associative arrays to store master and worker nodes
declare -A masters
declare -A workers
declare -A ami_map

# Check for missing dependencies
for prog in "${requirements[@]}"; do
    if ! command -v "$prog" >/dev/null 2>&1; then
        missing+=("$prog")
    fi
done

# Print the result of the dependency check
if [ ${#missing[@]} -eq 0 ]; then
    echo "✅ All the dependencies have been installed:"
else
    echo "❌ The following dependencies are missing:"
    for m in "${missing[@]}"; do
        echo "  - $m"
    done
    exit 1
fi

# Function to check SSH connectivity to a given host
check_ssh_connection() {
  local host=$1 # Takes the first argument as the host
  # Tries to SSH into the host with a timeout of 5 seconds and no strict host key checking
  ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa.pub ubuntu@"$host" 'echo SSH_OK' &>/dev/null
}

# Function to wait until all hosts of a given type (masters or workers) are reachable via SSH
wait_for_ssh() {
  local -n hosts=$1 # Use a nameref to refer to the array passed as the first argument
  local type=$2     # Type of host group ("masters" or "workers")
  echo "🔄 Waiting for SSH connection with all $type..."

  local pending=1
  while [[ $pending -ne 0 ]]; do
    pending=0
    for ip in "${hosts[@]}"; do
      echo -n "Check $ip... "
      if check_ssh_connection "$ip"; then
        echo "✅ OK"
      else
        echo "❌ Fail, retry in 5s..."
        pending=1
      fi
    done
    if [[ $pending -ne 0 ]]; then
      sleep 5
    fi
  done

  echo "✅ All the $type have SSH connection."
}

# Available OS options
options=("Ubuntu" "Debian" "CentOS")
selected=0

# Function to draw the OS selection menu
draw_menu() {
  clear
  echo "Welcome to K8Multinode, a program that makes it easy to deploy Kubernetes clusters in the cloud."
  echo "Select the operating system that your nodes (masters and workers) will have:"
  echo
  for i in "${!options[@]}"; do
    if [[ $i == $selected ]]; then
      echo -e "> \e[1;32m${options[$i]}\e[0m"
    else
      echo "  ${options[$i]}"
    fi
  done
}

# Main menu loop for OS selection
while true; do
  draw_menu
  read -rsn1 key
  if [[ $key == $'\x1b' ]]; then
    read -rsn2 -t 0.1 key2
    key+=$key2
  fi

  case "$key" in
    $'\x1b[A') # Up arrow
      ((selected--))
      if ((selected < 0)); then selected=$((${#options[@]} - 1)); fi
      ;;
    $'\x1b[B') # Down arrow
      ((selected++))
      if ((selected >= ${#options[@]})); then selected=0; fi
      ;;
    "") # Enter key
      break
      ;;
  esac
done

# Save the selected OS
selected_os="${options[$selected]}"

ami_id="${ami_map[$selected_os]}"

# Reset selection index for the Kubernetes version menu
selected=0

# Function to draw the Kubernetes version menu
draw_k8s_menu() {
  clear
  echo "Select the Kubernetes version to deploy:"
  echo
  for i in "${!k8s_versions[@]}"; do
    if [[ $i == $selected ]]; then
      echo -e "> \e[1;34m${k8s_versions[$i]}\e[0m"
    else
      echo "  ${k8s_versions[$i]}"
    fi
  done
}

# Menu loop for Kubernetes version selection
while true; do
  draw_k8s_menu
  read -rsn1 key
  if [[ $key == $'\x1b' ]]; then
    read -rsn2 -t 0.1 key2
    key+=$key2
  fi

  case "$key" in
    $'\x1b[A') # Up arrow
      ((selected--))
      if ((selected < 0)); then selected=$((${#k8s_versions[@]} - 1)); fi
      ;;
    $'\x1b[B') # Down arrow
      ((selected++))
      if ((selected >= ${#k8s_versions[@]})); then selected=0; fi
      ;;
    "") # Enter key
      break
      ;;
  esac
done

# Save selected version and its corresponding code
selected_k8s="${k8s_versions[$selected]}"
k8s_code="${k8s_version_codes[$selected]}"

# You can use these variables now:
# $selected_os, $ami_id, $selected_k8s, $k8s_code

# Example printout (can be removed)
echo
echo "You selected:"
echo "OS: $selected_os"
echo "AMI: $ami_id"
echo "Kubernetes version: $selected_k8s"
echo "K8s code: $k8s_code"


echo "Selected operating system: $selected_os"
echo "Corresponding AMI: $ami_id"

echo "Your Masters and Workers will be installed with ${options[$selected]}"

read -p "How many control nodes do you want: " n_control
read -p "How many worker nodes do you want: " n_workers

for ((i=1; i<=n_control; i++)); do
    cat >> "$main_file" <<EOF
module "k8_master_${i}" {
    source        = "./modules/master/ec2"
    instance_name = "K8-Master-${i}"
    ami           = var.ami
    instance_type = var.instance_type
    subnet_id     = module.k8_vpc.subnet_id
    key_name      = aws_key_pair.mykey.key_name
    vpc_security_group_ids = [module.ssh_sg.security_group_id]
}

EOF

    cat >> "$output_file" <<EOF
output "k8_master_${i}_public_ip" {
  value = module.k8_master_${i}.k8_masters_public_ip
}

output "k8_master_${i}_public_dns" {
  value = module.k8_master_${i}.k8_masters_public_dns
}

EOF
done

for ((i=1; i<=n_workers; i++)); do
    cat >> "$main_file" <<EOF
module "k8_worker_${i}" {
    source        = "./modules/worker/ec2"
    instance_name = "K8-Worker-${i}"
    instance_type = var.instance_type
    ami           = var.ami
    subnet_id     = module.k8_vpc.subnet_id
    key_name      = aws_key_pair.mykey.key_name
    vpc_security_group_ids = [module.ssh_sg.security_group_id]
}

EOF

    cat >> "$output_file" <<EOF
output "k8_worker_${i}_public_ip" {
  value = module.k8_worker_${i}.k8_workers_public_ip
}

output "k8_worker_${i}_public_dns" {
  value = module.k8_worker_${i}.k8_workers_public_dns
}

EOF

done

cat >> "$output_file" <<EOF
output "lb" {
  value = module.control_plane_lb.alb_dns_name
}
EOF

sed -i "s|image_id_replace|$ami_id|g" $variables_file

echo 'module "control_plane_lb" {' >> "$main_file"
echo '  source        = "./modules/lb"' >> "$main_file"
echo '  lb_name       = "k8s-cp-lb"' >> "$main_file"
echo '  vpc_id        = module.k8_vpc.vpc_id' >> "$main_file"
echo '  subnet_ids    = [module.k8_vpc.subnet_id]' >> "$main_file"
echo '  instance_ids  = [' >> "$main_file"

# Agregar cada instancia master al array de instance_ids
for ((i=1; i<=n_control; i++)); do
  if [[ $i -eq $n_control ]]; then
    echo "    module.k8_master_$i.instance_id" >> "$main_file"
  else
    echo "    module.k8_master_$i.instance_id," >> "$main_file"
  fi
done

echo '  ]' >> "$main_file"
echo '}' >> "$main_file"

# Navigate to the Terraform directory
cd terraform/

# Initialize and apply Terraform configuration
terraform init
terraform apply -auto-approve

# Output the generated IPs and store them in a file
terraform output > ips.txt

# Read the contents of the file
content=$(cat ips.txt)

echo "" > outputs.tf
#sed -i "s|$ami_id|image_id_replace|g" "$variables_file"
# Parse the IPs and DNS names from the output and populate the associative arrays
while IFS= read -r line; do
    name=$(echo "$line" | cut -d '=' -f1 | xargs)
    value=$(echo "$line" | cut -d '=' -f2- | tr -d '"' | xargs)
    if [[ "$name" == *"master"* ]]; then
        if [[ "$name" == *"public_dns" ]]; then
            current_dns="$value"
        elif [[ "$name" == *"public_ip" ]]; then
            masters["$current_dns"]="$value"
        fi
    elif [[ "$name" == *"worker"* ]]; then
        if [[ "$name" == *"public_dns" ]]; then
            current_dns="$value"
        elif [[ "$name" == *"public_ip" ]]; then
            workers["$current_dns"]="$value"
        fi
    fi
done <<< "$content"

# Append the load balancer DNS to the Ansible variables file
echo -e "\nload_balancer_dns: $(grep "lb =" ips.txt | cut -d"=" -f2 | xargs)" >> ../ansible/roles/master/vars/main.yml

# Go to the Ansible directory
cd ../ansible/

# Create the Ansible inventory file
echo "[k8-masters]" > inventory.ini
for dns in "${!masters[@]}"; do
    echo "$dns ansible_host=${masters[$dns]} env=$k8s_code" os=$selected_os >> inventory.ini
done

echo "" >> inventory.ini
echo "[k8-workers]" >> inventory.ini
for dns in "${!workers[@]}"; do
    echo "$dns ansible_host=${workers[$dns]} env=$k8s_code" os=$selected_os >> inventory.ini
done


# Clean up the temporary IP output file
rm -f ../terraform/ips.txt

# Wait for SSH to be ready on all hosts
echo "Wait for the Hosts"
wait_for_ssh masters "masters"
wait_for_ssh workers "workers"

# Run Ansible playbooks to configure the Kubernetes cluster
ansible-playbook -i inventory.ini playbooks/01-preconfig-kubernetes-servers.yml
ansible-playbook -i inventory.ini playbooks/02-configure-nodes.yml

# Remove the load balancer DNS variable after use to avoid future conflicts
grep -v 'load_balancer_dns:' roles/master/vars/main.yml > roles/master/vars/tmp && mv roles/master/vars/tmp roles/master/vars/main.yml

# Check if the ~/.kube directory exists
if [ ! -d "$KUBE_DIR" ]; then
    echo "Directorio $KUBE_DIR no existe. Creándolo..."
    mkdir -p "$KUBE_DIR"
fi

for dns in "${!masters[@]}"; do
    first_ip="${masters[$dns]}"
    break
done

# Check if the config file exists inside ~/.kube
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Archivo $CONFIG_FILE no existe. Creándolo..."
    touch "$CONFIG_FILE"
    ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no ubuntu@"$first_ip" 'cat ~/.kube/config' > "$CONFIG_FILE"
else
    echo "" >> "$CONFIG_FILE"
    ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no ubuntu@"$first_ip" 'cat ~/.kube/config' >> "$CONFIG_FILE"
fi
